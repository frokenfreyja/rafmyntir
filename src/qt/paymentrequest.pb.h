// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: paymentrequest.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_paymentrequest_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_paymentrequest_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3010000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3010000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_paymentrequest_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_paymentrequest_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_paymentrequest_2eproto;
namespace payments {
class Output;
class OutputDefaultTypeInternal;
extern OutputDefaultTypeInternal _Output_default_instance_;
class Payment;
class PaymentDefaultTypeInternal;
extern PaymentDefaultTypeInternal _Payment_default_instance_;
class PaymentACK;
class PaymentACKDefaultTypeInternal;
extern PaymentACKDefaultTypeInternal _PaymentACK_default_instance_;
class PaymentDetails;
class PaymentDetailsDefaultTypeInternal;
extern PaymentDetailsDefaultTypeInternal _PaymentDetails_default_instance_;
class PaymentRequest;
class PaymentRequestDefaultTypeInternal;
extern PaymentRequestDefaultTypeInternal _PaymentRequest_default_instance_;
class X509Certificates;
class X509CertificatesDefaultTypeInternal;
extern X509CertificatesDefaultTypeInternal _X509Certificates_default_instance_;
}  // namespace payments
PROTOBUF_NAMESPACE_OPEN
template<> ::payments::Output* Arena::CreateMaybeMessage<::payments::Output>(Arena*);
template<> ::payments::Payment* Arena::CreateMaybeMessage<::payments::Payment>(Arena*);
template<> ::payments::PaymentACK* Arena::CreateMaybeMessage<::payments::PaymentACK>(Arena*);
template<> ::payments::PaymentDetails* Arena::CreateMaybeMessage<::payments::PaymentDetails>(Arena*);
template<> ::payments::PaymentRequest* Arena::CreateMaybeMessage<::payments::PaymentRequest>(Arena*);
template<> ::payments::X509Certificates* Arena::CreateMaybeMessage<::payments::X509Certificates>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace payments {

// ===================================================================

class Output :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payments.Output) */ {
 public:
  Output();
  virtual ~Output();

  Output(const Output& from);
  Output(Output&& from) noexcept
    : Output() {
    *this = ::std::move(from);
  }

  inline Output& operator=(const Output& from) {
    CopyFrom(from);
    return *this;
  }
  inline Output& operator=(Output&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Output& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Output* internal_default_instance() {
    return reinterpret_cast<const Output*>(
               &_Output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Output& a, Output& b) {
    a.Swap(&b);
  }
  inline void Swap(Output* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Output* New() const final {
    return CreateMaybeMessage<Output>(nullptr);
  }

  Output* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Output>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Output& from);
  void MergeFrom(const Output& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Output* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payments.Output";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_paymentrequest_2eproto);
    return ::descriptor_table_paymentrequest_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScriptFieldNumber = 2,
    kAmountFieldNumber = 1,
  };
  // required bytes script = 2;
  bool has_script() const;
  private:
  bool _internal_has_script() const;
  public:
  void clear_script();
  const std::string& script() const;
  void set_script(const std::string& value);
  void set_script(std::string&& value);
  void set_script(const char* value);
  void set_script(const void* value, size_t size);
  std::string* mutable_script();
  std::string* release_script();
  void set_allocated_script(std::string* script);
  private:
  const std::string& _internal_script() const;
  void _internal_set_script(const std::string& value);
  std::string* _internal_mutable_script();
  public:

  // optional uint64 amount = 1 [default = 0];
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  ::PROTOBUF_NAMESPACE_ID::uint64 amount() const;
  void set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_amount() const;
  void _internal_set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:payments.Output)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr script_;
  ::PROTOBUF_NAMESPACE_ID::uint64 amount_;
  friend struct ::TableStruct_paymentrequest_2eproto;
};
// -------------------------------------------------------------------

class PaymentDetails :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payments.PaymentDetails) */ {
 public:
  PaymentDetails();
  virtual ~PaymentDetails();

  PaymentDetails(const PaymentDetails& from);
  PaymentDetails(PaymentDetails&& from) noexcept
    : PaymentDetails() {
    *this = ::std::move(from);
  }

  inline PaymentDetails& operator=(const PaymentDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaymentDetails& operator=(PaymentDetails&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PaymentDetails& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PaymentDetails* internal_default_instance() {
    return reinterpret_cast<const PaymentDetails*>(
               &_PaymentDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PaymentDetails& a, PaymentDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(PaymentDetails* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PaymentDetails* New() const final {
    return CreateMaybeMessage<PaymentDetails>(nullptr);
  }

  PaymentDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PaymentDetails>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PaymentDetails& from);
  void MergeFrom(const PaymentDetails& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaymentDetails* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payments.PaymentDetails";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_paymentrequest_2eproto);
    return ::descriptor_table_paymentrequest_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutputsFieldNumber = 2,
    kNetworkFieldNumber = 1,
    kMemoFieldNumber = 5,
    kPaymentUrlFieldNumber = 6,
    kMerchantDataFieldNumber = 7,
    kTimeFieldNumber = 3,
    kExpiresFieldNumber = 4,
  };
  // repeated .payments.Output outputs = 2;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;
  public:
  void clear_outputs();
  ::payments::Output* mutable_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payments::Output >*
      mutable_outputs();
  private:
  const ::payments::Output& _internal_outputs(int index) const;
  ::payments::Output* _internal_add_outputs();
  public:
  const ::payments::Output& outputs(int index) const;
  ::payments::Output* add_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payments::Output >&
      outputs() const;

  // optional string network = 1 [default = "main"];
  bool has_network() const;
  private:
  bool _internal_has_network() const;
  public:
  void clear_network();
  const std::string& network() const;
  void set_network(const std::string& value);
  void set_network(std::string&& value);
  void set_network(const char* value);
  void set_network(const char* value, size_t size);
  std::string* mutable_network();
  std::string* release_network();
  void set_allocated_network(std::string* network);
  private:
  const std::string& _internal_network() const;
  void _internal_set_network(const std::string& value);
  std::string* _internal_mutable_network();
  public:

  // optional string memo = 5;
  bool has_memo() const;
  private:
  bool _internal_has_memo() const;
  public:
  void clear_memo();
  const std::string& memo() const;
  void set_memo(const std::string& value);
  void set_memo(std::string&& value);
  void set_memo(const char* value);
  void set_memo(const char* value, size_t size);
  std::string* mutable_memo();
  std::string* release_memo();
  void set_allocated_memo(std::string* memo);
  private:
  const std::string& _internal_memo() const;
  void _internal_set_memo(const std::string& value);
  std::string* _internal_mutable_memo();
  public:

  // optional string payment_url = 6;
  bool has_payment_url() const;
  private:
  bool _internal_has_payment_url() const;
  public:
  void clear_payment_url();
  const std::string& payment_url() const;
  void set_payment_url(const std::string& value);
  void set_payment_url(std::string&& value);
  void set_payment_url(const char* value);
  void set_payment_url(const char* value, size_t size);
  std::string* mutable_payment_url();
  std::string* release_payment_url();
  void set_allocated_payment_url(std::string* payment_url);
  private:
  const std::string& _internal_payment_url() const;
  void _internal_set_payment_url(const std::string& value);
  std::string* _internal_mutable_payment_url();
  public:

  // optional bytes merchant_data = 7;
  bool has_merchant_data() const;
  private:
  bool _internal_has_merchant_data() const;
  public:
  void clear_merchant_data();
  const std::string& merchant_data() const;
  void set_merchant_data(const std::string& value);
  void set_merchant_data(std::string&& value);
  void set_merchant_data(const char* value);
  void set_merchant_data(const void* value, size_t size);
  std::string* mutable_merchant_data();
  std::string* release_merchant_data();
  void set_allocated_merchant_data(std::string* merchant_data);
  private:
  const std::string& _internal_merchant_data() const;
  void _internal_set_merchant_data(const std::string& value);
  std::string* _internal_mutable_merchant_data();
  public:

  // required uint64 time = 3;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 time() const;
  void set_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_time() const;
  void _internal_set_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 expires = 4;
  bool has_expires() const;
  private:
  bool _internal_has_expires() const;
  public:
  void clear_expires();
  ::PROTOBUF_NAMESPACE_ID::uint64 expires() const;
  void set_expires(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_expires() const;
  void _internal_set_expires(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:payments.PaymentDetails)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payments::Output > outputs_;
  public:
  static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> _i_give_permission_to_break_this_code_default_network_;
  private:
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memo_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payment_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr merchant_data_;
  ::PROTOBUF_NAMESPACE_ID::uint64 time_;
  ::PROTOBUF_NAMESPACE_ID::uint64 expires_;
  friend struct ::TableStruct_paymentrequest_2eproto;
};
// -------------------------------------------------------------------

class PaymentRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payments.PaymentRequest) */ {
 public:
  PaymentRequest();
  virtual ~PaymentRequest();

  PaymentRequest(const PaymentRequest& from);
  PaymentRequest(PaymentRequest&& from) noexcept
    : PaymentRequest() {
    *this = ::std::move(from);
  }

  inline PaymentRequest& operator=(const PaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaymentRequest& operator=(PaymentRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PaymentRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PaymentRequest* internal_default_instance() {
    return reinterpret_cast<const PaymentRequest*>(
               &_PaymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PaymentRequest& a, PaymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PaymentRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PaymentRequest* New() const final {
    return CreateMaybeMessage<PaymentRequest>(nullptr);
  }

  PaymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PaymentRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PaymentRequest& from);
  void MergeFrom(const PaymentRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaymentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payments.PaymentRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_paymentrequest_2eproto);
    return ::descriptor_table_paymentrequest_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPkiTypeFieldNumber = 2,
    kPkiDataFieldNumber = 3,
    kSerializedPaymentDetailsFieldNumber = 4,
    kSignatureFieldNumber = 5,
    kPaymentDetailsVersionFieldNumber = 1,
  };
  // optional string pki_type = 2 [default = "none"];
  bool has_pki_type() const;
  private:
  bool _internal_has_pki_type() const;
  public:
  void clear_pki_type();
  const std::string& pki_type() const;
  void set_pki_type(const std::string& value);
  void set_pki_type(std::string&& value);
  void set_pki_type(const char* value);
  void set_pki_type(const char* value, size_t size);
  std::string* mutable_pki_type();
  std::string* release_pki_type();
  void set_allocated_pki_type(std::string* pki_type);
  private:
  const std::string& _internal_pki_type() const;
  void _internal_set_pki_type(const std::string& value);
  std::string* _internal_mutable_pki_type();
  public:

  // optional bytes pki_data = 3;
  bool has_pki_data() const;
  private:
  bool _internal_has_pki_data() const;
  public:
  void clear_pki_data();
  const std::string& pki_data() const;
  void set_pki_data(const std::string& value);
  void set_pki_data(std::string&& value);
  void set_pki_data(const char* value);
  void set_pki_data(const void* value, size_t size);
  std::string* mutable_pki_data();
  std::string* release_pki_data();
  void set_allocated_pki_data(std::string* pki_data);
  private:
  const std::string& _internal_pki_data() const;
  void _internal_set_pki_data(const std::string& value);
  std::string* _internal_mutable_pki_data();
  public:

  // required bytes serialized_payment_details = 4;
  bool has_serialized_payment_details() const;
  private:
  bool _internal_has_serialized_payment_details() const;
  public:
  void clear_serialized_payment_details();
  const std::string& serialized_payment_details() const;
  void set_serialized_payment_details(const std::string& value);
  void set_serialized_payment_details(std::string&& value);
  void set_serialized_payment_details(const char* value);
  void set_serialized_payment_details(const void* value, size_t size);
  std::string* mutable_serialized_payment_details();
  std::string* release_serialized_payment_details();
  void set_allocated_serialized_payment_details(std::string* serialized_payment_details);
  private:
  const std::string& _internal_serialized_payment_details() const;
  void _internal_set_serialized_payment_details(const std::string& value);
  std::string* _internal_mutable_serialized_payment_details();
  public:

  // optional bytes signature = 5;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  void set_signature(const std::string& value);
  void set_signature(std::string&& value);
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  std::string* mutable_signature();
  std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // optional uint32 payment_details_version = 1 [default = 1];
  bool has_payment_details_version() const;
  private:
  bool _internal_has_payment_details_version() const;
  public:
  void clear_payment_details_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 payment_details_version() const;
  void set_payment_details_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_payment_details_version() const;
  void _internal_set_payment_details_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payments.PaymentRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  public:
  static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> _i_give_permission_to_break_this_code_default_pki_type_;
  private:
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pki_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pki_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialized_payment_details_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::uint32 payment_details_version_;
  friend struct ::TableStruct_paymentrequest_2eproto;
};
// -------------------------------------------------------------------

class X509Certificates :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payments.X509Certificates) */ {
 public:
  X509Certificates();
  virtual ~X509Certificates();

  X509Certificates(const X509Certificates& from);
  X509Certificates(X509Certificates&& from) noexcept
    : X509Certificates() {
    *this = ::std::move(from);
  }

  inline X509Certificates& operator=(const X509Certificates& from) {
    CopyFrom(from);
    return *this;
  }
  inline X509Certificates& operator=(X509Certificates&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const X509Certificates& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const X509Certificates* internal_default_instance() {
    return reinterpret_cast<const X509Certificates*>(
               &_X509Certificates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(X509Certificates& a, X509Certificates& b) {
    a.Swap(&b);
  }
  inline void Swap(X509Certificates* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline X509Certificates* New() const final {
    return CreateMaybeMessage<X509Certificates>(nullptr);
  }

  X509Certificates* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<X509Certificates>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const X509Certificates& from);
  void MergeFrom(const X509Certificates& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(X509Certificates* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payments.X509Certificates";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_paymentrequest_2eproto);
    return ::descriptor_table_paymentrequest_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCertificateFieldNumber = 1,
  };
  // repeated bytes certificate = 1;
  int certificate_size() const;
  private:
  int _internal_certificate_size() const;
  public:
  void clear_certificate();
  const std::string& certificate(int index) const;
  std::string* mutable_certificate(int index);
  void set_certificate(int index, const std::string& value);
  void set_certificate(int index, std::string&& value);
  void set_certificate(int index, const char* value);
  void set_certificate(int index, const void* value, size_t size);
  std::string* add_certificate();
  void add_certificate(const std::string& value);
  void add_certificate(std::string&& value);
  void add_certificate(const char* value);
  void add_certificate(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& certificate() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_certificate();
  private:
  const std::string& _internal_certificate(int index) const;
  std::string* _internal_add_certificate();
  public:

  // @@protoc_insertion_point(class_scope:payments.X509Certificates)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> certificate_;
  friend struct ::TableStruct_paymentrequest_2eproto;
};
// -------------------------------------------------------------------

class Payment :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payments.Payment) */ {
 public:
  Payment();
  virtual ~Payment();

  Payment(const Payment& from);
  Payment(Payment&& from) noexcept
    : Payment() {
    *this = ::std::move(from);
  }

  inline Payment& operator=(const Payment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Payment& operator=(Payment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Payment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Payment* internal_default_instance() {
    return reinterpret_cast<const Payment*>(
               &_Payment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Payment& a, Payment& b) {
    a.Swap(&b);
  }
  inline void Swap(Payment* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Payment* New() const final {
    return CreateMaybeMessage<Payment>(nullptr);
  }

  Payment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Payment>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Payment& from);
  void MergeFrom(const Payment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Payment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payments.Payment";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_paymentrequest_2eproto);
    return ::descriptor_table_paymentrequest_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionsFieldNumber = 2,
    kRefundToFieldNumber = 3,
    kMerchantDataFieldNumber = 1,
    kMemoFieldNumber = 4,
  };
  // repeated bytes transactions = 2;
  int transactions_size() const;
  private:
  int _internal_transactions_size() const;
  public:
  void clear_transactions();
  const std::string& transactions(int index) const;
  std::string* mutable_transactions(int index);
  void set_transactions(int index, const std::string& value);
  void set_transactions(int index, std::string&& value);
  void set_transactions(int index, const char* value);
  void set_transactions(int index, const void* value, size_t size);
  std::string* add_transactions();
  void add_transactions(const std::string& value);
  void add_transactions(std::string&& value);
  void add_transactions(const char* value);
  void add_transactions(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& transactions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_transactions();
  private:
  const std::string& _internal_transactions(int index) const;
  std::string* _internal_add_transactions();
  public:

  // repeated .payments.Output refund_to = 3;
  int refund_to_size() const;
  private:
  int _internal_refund_to_size() const;
  public:
  void clear_refund_to();
  ::payments::Output* mutable_refund_to(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payments::Output >*
      mutable_refund_to();
  private:
  const ::payments::Output& _internal_refund_to(int index) const;
  ::payments::Output* _internal_add_refund_to();
  public:
  const ::payments::Output& refund_to(int index) const;
  ::payments::Output* add_refund_to();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payments::Output >&
      refund_to() const;

  // optional bytes merchant_data = 1;
  bool has_merchant_data() const;
  private:
  bool _internal_has_merchant_data() const;
  public:
  void clear_merchant_data();
  const std::string& merchant_data() const;
  void set_merchant_data(const std::string& value);
  void set_merchant_data(std::string&& value);
  void set_merchant_data(const char* value);
  void set_merchant_data(const void* value, size_t size);
  std::string* mutable_merchant_data();
  std::string* release_merchant_data();
  void set_allocated_merchant_data(std::string* merchant_data);
  private:
  const std::string& _internal_merchant_data() const;
  void _internal_set_merchant_data(const std::string& value);
  std::string* _internal_mutable_merchant_data();
  public:

  // optional string memo = 4;
  bool has_memo() const;
  private:
  bool _internal_has_memo() const;
  public:
  void clear_memo();
  const std::string& memo() const;
  void set_memo(const std::string& value);
  void set_memo(std::string&& value);
  void set_memo(const char* value);
  void set_memo(const char* value, size_t size);
  std::string* mutable_memo();
  std::string* release_memo();
  void set_allocated_memo(std::string* memo);
  private:
  const std::string& _internal_memo() const;
  void _internal_set_memo(const std::string& value);
  std::string* _internal_mutable_memo();
  public:

  // @@protoc_insertion_point(class_scope:payments.Payment)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> transactions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payments::Output > refund_to_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr merchant_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memo_;
  friend struct ::TableStruct_paymentrequest_2eproto;
};
// -------------------------------------------------------------------

class PaymentACK :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payments.PaymentACK) */ {
 public:
  PaymentACK();
  virtual ~PaymentACK();

  PaymentACK(const PaymentACK& from);
  PaymentACK(PaymentACK&& from) noexcept
    : PaymentACK() {
    *this = ::std::move(from);
  }

  inline PaymentACK& operator=(const PaymentACK& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaymentACK& operator=(PaymentACK&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PaymentACK& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PaymentACK* internal_default_instance() {
    return reinterpret_cast<const PaymentACK*>(
               &_PaymentACK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PaymentACK& a, PaymentACK& b) {
    a.Swap(&b);
  }
  inline void Swap(PaymentACK* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PaymentACK* New() const final {
    return CreateMaybeMessage<PaymentACK>(nullptr);
  }

  PaymentACK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PaymentACK>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PaymentACK& from);
  void MergeFrom(const PaymentACK& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaymentACK* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payments.PaymentACK";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_paymentrequest_2eproto);
    return ::descriptor_table_paymentrequest_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemoFieldNumber = 2,
    kPaymentFieldNumber = 1,
  };
  // optional string memo = 2;
  bool has_memo() const;
  private:
  bool _internal_has_memo() const;
  public:
  void clear_memo();
  const std::string& memo() const;
  void set_memo(const std::string& value);
  void set_memo(std::string&& value);
  void set_memo(const char* value);
  void set_memo(const char* value, size_t size);
  std::string* mutable_memo();
  std::string* release_memo();
  void set_allocated_memo(std::string* memo);
  private:
  const std::string& _internal_memo() const;
  void _internal_set_memo(const std::string& value);
  std::string* _internal_mutable_memo();
  public:

  // required .payments.Payment payment = 1;
  bool has_payment() const;
  private:
  bool _internal_has_payment() const;
  public:
  void clear_payment();
  const ::payments::Payment& payment() const;
  ::payments::Payment* release_payment();
  ::payments::Payment* mutable_payment();
  void set_allocated_payment(::payments::Payment* payment);
  private:
  const ::payments::Payment& _internal_payment() const;
  ::payments::Payment* _internal_mutable_payment();
  public:

  // @@protoc_insertion_point(class_scope:payments.PaymentACK)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memo_;
  ::payments::Payment* payment_;
  friend struct ::TableStruct_paymentrequest_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Output

// optional uint64 amount = 1 [default = 0];
inline bool Output::_internal_has_amount() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Output::has_amount() const {
  return _internal_has_amount();
}
inline void Output::clear_amount() {
  amount_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Output::_internal_amount() const {
  return amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Output::amount() const {
  // @@protoc_insertion_point(field_get:payments.Output.amount)
  return _internal_amount();
}
inline void Output::_internal_set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  amount_ = value;
}
inline void Output::set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:payments.Output.amount)
}

// required bytes script = 2;
inline bool Output::_internal_has_script() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Output::has_script() const {
  return _internal_has_script();
}
inline void Output::clear_script() {
  script_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Output::script() const {
  // @@protoc_insertion_point(field_get:payments.Output.script)
  return _internal_script();
}
inline void Output::set_script(const std::string& value) {
  _internal_set_script(value);
  // @@protoc_insertion_point(field_set:payments.Output.script)
}
inline std::string* Output::mutable_script() {
  // @@protoc_insertion_point(field_mutable:payments.Output.script)
  return _internal_mutable_script();
}
inline const std::string& Output::_internal_script() const {
  return script_.GetNoArena();
}
inline void Output::_internal_set_script(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  script_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Output::set_script(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  script_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.Output.script)
}
inline void Output::set_script(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  script_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.Output.script)
}
inline void Output::set_script(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  script_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.Output.script)
}
inline std::string* Output::_internal_mutable_script() {
  _has_bits_[0] |= 0x00000001u;
  return script_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Output::release_script() {
  // @@protoc_insertion_point(field_release:payments.Output.script)
  if (!has_script()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return script_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Output::set_allocated_script(std::string* script) {
  if (script != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  script_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), script);
  // @@protoc_insertion_point(field_set_allocated:payments.Output.script)
}

// -------------------------------------------------------------------

// PaymentDetails

// optional string network = 1 [default = "main"];
inline bool PaymentDetails::_internal_has_network() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PaymentDetails::has_network() const {
  return _internal_has_network();
}
inline void PaymentDetails::clear_network() {
  network_.ClearToDefaultNoArena(&::payments::PaymentDetails::_i_give_permission_to_break_this_code_default_network_.get());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PaymentDetails::network() const {
  // @@protoc_insertion_point(field_get:payments.PaymentDetails.network)
  return _internal_network();
}
inline void PaymentDetails::set_network(const std::string& value) {
  _internal_set_network(value);
  // @@protoc_insertion_point(field_set:payments.PaymentDetails.network)
}
inline std::string* PaymentDetails::mutable_network() {
  // @@protoc_insertion_point(field_mutable:payments.PaymentDetails.network)
  return _internal_mutable_network();
}
inline const std::string& PaymentDetails::_internal_network() const {
  return network_.GetNoArena();
}
inline void PaymentDetails::_internal_set_network(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  network_.SetNoArena(&::payments::PaymentDetails::_i_give_permission_to_break_this_code_default_network_.get(), value);
}
inline void PaymentDetails::set_network(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  network_.SetNoArena(
    &::payments::PaymentDetails::_i_give_permission_to_break_this_code_default_network_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.PaymentDetails.network)
}
inline void PaymentDetails::set_network(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  network_.SetNoArena(&::payments::PaymentDetails::_i_give_permission_to_break_this_code_default_network_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.PaymentDetails.network)
}
inline void PaymentDetails::set_network(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  network_.SetNoArena(&::payments::PaymentDetails::_i_give_permission_to_break_this_code_default_network_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.PaymentDetails.network)
}
inline std::string* PaymentDetails::_internal_mutable_network() {
  _has_bits_[0] |= 0x00000001u;
  return network_.MutableNoArena(&::payments::PaymentDetails::_i_give_permission_to_break_this_code_default_network_.get());
}
inline std::string* PaymentDetails::release_network() {
  // @@protoc_insertion_point(field_release:payments.PaymentDetails.network)
  if (!has_network()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return network_.ReleaseNonDefaultNoArena(&::payments::PaymentDetails::_i_give_permission_to_break_this_code_default_network_.get());
}
inline void PaymentDetails::set_allocated_network(std::string* network) {
  if (network != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  network_.SetAllocatedNoArena(&::payments::PaymentDetails::_i_give_permission_to_break_this_code_default_network_.get(), network);
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentDetails.network)
}

// repeated .payments.Output outputs = 2;
inline int PaymentDetails::_internal_outputs_size() const {
  return outputs_.size();
}
inline int PaymentDetails::outputs_size() const {
  return _internal_outputs_size();
}
inline void PaymentDetails::clear_outputs() {
  outputs_.Clear();
}
inline ::payments::Output* PaymentDetails::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:payments.PaymentDetails.outputs)
  return outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payments::Output >*
PaymentDetails::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:payments.PaymentDetails.outputs)
  return &outputs_;
}
inline const ::payments::Output& PaymentDetails::_internal_outputs(int index) const {
  return outputs_.Get(index);
}
inline const ::payments::Output& PaymentDetails::outputs(int index) const {
  // @@protoc_insertion_point(field_get:payments.PaymentDetails.outputs)
  return _internal_outputs(index);
}
inline ::payments::Output* PaymentDetails::_internal_add_outputs() {
  return outputs_.Add();
}
inline ::payments::Output* PaymentDetails::add_outputs() {
  // @@protoc_insertion_point(field_add:payments.PaymentDetails.outputs)
  return _internal_add_outputs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payments::Output >&
PaymentDetails::outputs() const {
  // @@protoc_insertion_point(field_list:payments.PaymentDetails.outputs)
  return outputs_;
}

// required uint64 time = 3;
inline bool PaymentDetails::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PaymentDetails::has_time() const {
  return _internal_has_time();
}
inline void PaymentDetails::clear_time() {
  time_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PaymentDetails::_internal_time() const {
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PaymentDetails::time() const {
  // @@protoc_insertion_point(field_get:payments.PaymentDetails.time)
  return _internal_time();
}
inline void PaymentDetails::_internal_set_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  time_ = value;
}
inline void PaymentDetails::set_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:payments.PaymentDetails.time)
}

// optional uint64 expires = 4;
inline bool PaymentDetails::_internal_has_expires() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PaymentDetails::has_expires() const {
  return _internal_has_expires();
}
inline void PaymentDetails::clear_expires() {
  expires_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PaymentDetails::_internal_expires() const {
  return expires_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PaymentDetails::expires() const {
  // @@protoc_insertion_point(field_get:payments.PaymentDetails.expires)
  return _internal_expires();
}
inline void PaymentDetails::_internal_set_expires(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  expires_ = value;
}
inline void PaymentDetails::set_expires(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_expires(value);
  // @@protoc_insertion_point(field_set:payments.PaymentDetails.expires)
}

// optional string memo = 5;
inline bool PaymentDetails::_internal_has_memo() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PaymentDetails::has_memo() const {
  return _internal_has_memo();
}
inline void PaymentDetails::clear_memo() {
  memo_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PaymentDetails::memo() const {
  // @@protoc_insertion_point(field_get:payments.PaymentDetails.memo)
  return _internal_memo();
}
inline void PaymentDetails::set_memo(const std::string& value) {
  _internal_set_memo(value);
  // @@protoc_insertion_point(field_set:payments.PaymentDetails.memo)
}
inline std::string* PaymentDetails::mutable_memo() {
  // @@protoc_insertion_point(field_mutable:payments.PaymentDetails.memo)
  return _internal_mutable_memo();
}
inline const std::string& PaymentDetails::_internal_memo() const {
  return memo_.GetNoArena();
}
inline void PaymentDetails::_internal_set_memo(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  memo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void PaymentDetails::set_memo(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  memo_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.PaymentDetails.memo)
}
inline void PaymentDetails::set_memo(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  memo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.PaymentDetails.memo)
}
inline void PaymentDetails::set_memo(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  memo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.PaymentDetails.memo)
}
inline std::string* PaymentDetails::_internal_mutable_memo() {
  _has_bits_[0] |= 0x00000002u;
  return memo_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PaymentDetails::release_memo() {
  // @@protoc_insertion_point(field_release:payments.PaymentDetails.memo)
  if (!has_memo()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return memo_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PaymentDetails::set_allocated_memo(std::string* memo) {
  if (memo != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  memo_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), memo);
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentDetails.memo)
}

// optional string payment_url = 6;
inline bool PaymentDetails::_internal_has_payment_url() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PaymentDetails::has_payment_url() const {
  return _internal_has_payment_url();
}
inline void PaymentDetails::clear_payment_url() {
  payment_url_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PaymentDetails::payment_url() const {
  // @@protoc_insertion_point(field_get:payments.PaymentDetails.payment_url)
  return _internal_payment_url();
}
inline void PaymentDetails::set_payment_url(const std::string& value) {
  _internal_set_payment_url(value);
  // @@protoc_insertion_point(field_set:payments.PaymentDetails.payment_url)
}
inline std::string* PaymentDetails::mutable_payment_url() {
  // @@protoc_insertion_point(field_mutable:payments.PaymentDetails.payment_url)
  return _internal_mutable_payment_url();
}
inline const std::string& PaymentDetails::_internal_payment_url() const {
  return payment_url_.GetNoArena();
}
inline void PaymentDetails::_internal_set_payment_url(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  payment_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void PaymentDetails::set_payment_url(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  payment_url_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.PaymentDetails.payment_url)
}
inline void PaymentDetails::set_payment_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  payment_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.PaymentDetails.payment_url)
}
inline void PaymentDetails::set_payment_url(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  payment_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.PaymentDetails.payment_url)
}
inline std::string* PaymentDetails::_internal_mutable_payment_url() {
  _has_bits_[0] |= 0x00000004u;
  return payment_url_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PaymentDetails::release_payment_url() {
  // @@protoc_insertion_point(field_release:payments.PaymentDetails.payment_url)
  if (!has_payment_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return payment_url_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PaymentDetails::set_allocated_payment_url(std::string* payment_url) {
  if (payment_url != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  payment_url_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payment_url);
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentDetails.payment_url)
}

// optional bytes merchant_data = 7;
inline bool PaymentDetails::_internal_has_merchant_data() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PaymentDetails::has_merchant_data() const {
  return _internal_has_merchant_data();
}
inline void PaymentDetails::clear_merchant_data() {
  merchant_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PaymentDetails::merchant_data() const {
  // @@protoc_insertion_point(field_get:payments.PaymentDetails.merchant_data)
  return _internal_merchant_data();
}
inline void PaymentDetails::set_merchant_data(const std::string& value) {
  _internal_set_merchant_data(value);
  // @@protoc_insertion_point(field_set:payments.PaymentDetails.merchant_data)
}
inline std::string* PaymentDetails::mutable_merchant_data() {
  // @@protoc_insertion_point(field_mutable:payments.PaymentDetails.merchant_data)
  return _internal_mutable_merchant_data();
}
inline const std::string& PaymentDetails::_internal_merchant_data() const {
  return merchant_data_.GetNoArena();
}
inline void PaymentDetails::_internal_set_merchant_data(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  merchant_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void PaymentDetails::set_merchant_data(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  merchant_data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.PaymentDetails.merchant_data)
}
inline void PaymentDetails::set_merchant_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  merchant_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.PaymentDetails.merchant_data)
}
inline void PaymentDetails::set_merchant_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  merchant_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.PaymentDetails.merchant_data)
}
inline std::string* PaymentDetails::_internal_mutable_merchant_data() {
  _has_bits_[0] |= 0x00000008u;
  return merchant_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PaymentDetails::release_merchant_data() {
  // @@protoc_insertion_point(field_release:payments.PaymentDetails.merchant_data)
  if (!has_merchant_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return merchant_data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PaymentDetails::set_allocated_merchant_data(std::string* merchant_data) {
  if (merchant_data != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  merchant_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), merchant_data);
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentDetails.merchant_data)
}

// -------------------------------------------------------------------

// PaymentRequest

// optional uint32 payment_details_version = 1 [default = 1];
inline bool PaymentRequest::_internal_has_payment_details_version() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PaymentRequest::has_payment_details_version() const {
  return _internal_has_payment_details_version();
}
inline void PaymentRequest::clear_payment_details_version() {
  payment_details_version_ = 1u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PaymentRequest::_internal_payment_details_version() const {
  return payment_details_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PaymentRequest::payment_details_version() const {
  // @@protoc_insertion_point(field_get:payments.PaymentRequest.payment_details_version)
  return _internal_payment_details_version();
}
inline void PaymentRequest::_internal_set_payment_details_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  payment_details_version_ = value;
}
inline void PaymentRequest::set_payment_details_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_payment_details_version(value);
  // @@protoc_insertion_point(field_set:payments.PaymentRequest.payment_details_version)
}

// optional string pki_type = 2 [default = "none"];
inline bool PaymentRequest::_internal_has_pki_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PaymentRequest::has_pki_type() const {
  return _internal_has_pki_type();
}
inline void PaymentRequest::clear_pki_type() {
  pki_type_.ClearToDefaultNoArena(&::payments::PaymentRequest::_i_give_permission_to_break_this_code_default_pki_type_.get());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PaymentRequest::pki_type() const {
  // @@protoc_insertion_point(field_get:payments.PaymentRequest.pki_type)
  return _internal_pki_type();
}
inline void PaymentRequest::set_pki_type(const std::string& value) {
  _internal_set_pki_type(value);
  // @@protoc_insertion_point(field_set:payments.PaymentRequest.pki_type)
}
inline std::string* PaymentRequest::mutable_pki_type() {
  // @@protoc_insertion_point(field_mutable:payments.PaymentRequest.pki_type)
  return _internal_mutable_pki_type();
}
inline const std::string& PaymentRequest::_internal_pki_type() const {
  return pki_type_.GetNoArena();
}
inline void PaymentRequest::_internal_set_pki_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  pki_type_.SetNoArena(&::payments::PaymentRequest::_i_give_permission_to_break_this_code_default_pki_type_.get(), value);
}
inline void PaymentRequest::set_pki_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  pki_type_.SetNoArena(
    &::payments::PaymentRequest::_i_give_permission_to_break_this_code_default_pki_type_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.PaymentRequest.pki_type)
}
inline void PaymentRequest::set_pki_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  pki_type_.SetNoArena(&::payments::PaymentRequest::_i_give_permission_to_break_this_code_default_pki_type_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.PaymentRequest.pki_type)
}
inline void PaymentRequest::set_pki_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  pki_type_.SetNoArena(&::payments::PaymentRequest::_i_give_permission_to_break_this_code_default_pki_type_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.PaymentRequest.pki_type)
}
inline std::string* PaymentRequest::_internal_mutable_pki_type() {
  _has_bits_[0] |= 0x00000001u;
  return pki_type_.MutableNoArena(&::payments::PaymentRequest::_i_give_permission_to_break_this_code_default_pki_type_.get());
}
inline std::string* PaymentRequest::release_pki_type() {
  // @@protoc_insertion_point(field_release:payments.PaymentRequest.pki_type)
  if (!has_pki_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return pki_type_.ReleaseNonDefaultNoArena(&::payments::PaymentRequest::_i_give_permission_to_break_this_code_default_pki_type_.get());
}
inline void PaymentRequest::set_allocated_pki_type(std::string* pki_type) {
  if (pki_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pki_type_.SetAllocatedNoArena(&::payments::PaymentRequest::_i_give_permission_to_break_this_code_default_pki_type_.get(), pki_type);
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentRequest.pki_type)
}

// optional bytes pki_data = 3;
inline bool PaymentRequest::_internal_has_pki_data() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PaymentRequest::has_pki_data() const {
  return _internal_has_pki_data();
}
inline void PaymentRequest::clear_pki_data() {
  pki_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PaymentRequest::pki_data() const {
  // @@protoc_insertion_point(field_get:payments.PaymentRequest.pki_data)
  return _internal_pki_data();
}
inline void PaymentRequest::set_pki_data(const std::string& value) {
  _internal_set_pki_data(value);
  // @@protoc_insertion_point(field_set:payments.PaymentRequest.pki_data)
}
inline std::string* PaymentRequest::mutable_pki_data() {
  // @@protoc_insertion_point(field_mutable:payments.PaymentRequest.pki_data)
  return _internal_mutable_pki_data();
}
inline const std::string& PaymentRequest::_internal_pki_data() const {
  return pki_data_.GetNoArena();
}
inline void PaymentRequest::_internal_set_pki_data(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  pki_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void PaymentRequest::set_pki_data(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  pki_data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.PaymentRequest.pki_data)
}
inline void PaymentRequest::set_pki_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  pki_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.PaymentRequest.pki_data)
}
inline void PaymentRequest::set_pki_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  pki_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.PaymentRequest.pki_data)
}
inline std::string* PaymentRequest::_internal_mutable_pki_data() {
  _has_bits_[0] |= 0x00000002u;
  return pki_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PaymentRequest::release_pki_data() {
  // @@protoc_insertion_point(field_release:payments.PaymentRequest.pki_data)
  if (!has_pki_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return pki_data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PaymentRequest::set_allocated_pki_data(std::string* pki_data) {
  if (pki_data != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pki_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pki_data);
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentRequest.pki_data)
}

// required bytes serialized_payment_details = 4;
inline bool PaymentRequest::_internal_has_serialized_payment_details() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PaymentRequest::has_serialized_payment_details() const {
  return _internal_has_serialized_payment_details();
}
inline void PaymentRequest::clear_serialized_payment_details() {
  serialized_payment_details_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PaymentRequest::serialized_payment_details() const {
  // @@protoc_insertion_point(field_get:payments.PaymentRequest.serialized_payment_details)
  return _internal_serialized_payment_details();
}
inline void PaymentRequest::set_serialized_payment_details(const std::string& value) {
  _internal_set_serialized_payment_details(value);
  // @@protoc_insertion_point(field_set:payments.PaymentRequest.serialized_payment_details)
}
inline std::string* PaymentRequest::mutable_serialized_payment_details() {
  // @@protoc_insertion_point(field_mutable:payments.PaymentRequest.serialized_payment_details)
  return _internal_mutable_serialized_payment_details();
}
inline const std::string& PaymentRequest::_internal_serialized_payment_details() const {
  return serialized_payment_details_.GetNoArena();
}
inline void PaymentRequest::_internal_set_serialized_payment_details(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  serialized_payment_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void PaymentRequest::set_serialized_payment_details(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  serialized_payment_details_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.PaymentRequest.serialized_payment_details)
}
inline void PaymentRequest::set_serialized_payment_details(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  serialized_payment_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.PaymentRequest.serialized_payment_details)
}
inline void PaymentRequest::set_serialized_payment_details(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  serialized_payment_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.PaymentRequest.serialized_payment_details)
}
inline std::string* PaymentRequest::_internal_mutable_serialized_payment_details() {
  _has_bits_[0] |= 0x00000004u;
  return serialized_payment_details_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PaymentRequest::release_serialized_payment_details() {
  // @@protoc_insertion_point(field_release:payments.PaymentRequest.serialized_payment_details)
  if (!has_serialized_payment_details()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return serialized_payment_details_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PaymentRequest::set_allocated_serialized_payment_details(std::string* serialized_payment_details) {
  if (serialized_payment_details != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  serialized_payment_details_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serialized_payment_details);
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentRequest.serialized_payment_details)
}

// optional bytes signature = 5;
inline bool PaymentRequest::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PaymentRequest::has_signature() const {
  return _internal_has_signature();
}
inline void PaymentRequest::clear_signature() {
  signature_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PaymentRequest::signature() const {
  // @@protoc_insertion_point(field_get:payments.PaymentRequest.signature)
  return _internal_signature();
}
inline void PaymentRequest::set_signature(const std::string& value) {
  _internal_set_signature(value);
  // @@protoc_insertion_point(field_set:payments.PaymentRequest.signature)
}
inline std::string* PaymentRequest::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:payments.PaymentRequest.signature)
  return _internal_mutable_signature();
}
inline const std::string& PaymentRequest::_internal_signature() const {
  return signature_.GetNoArena();
}
inline void PaymentRequest::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void PaymentRequest::set_signature(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  signature_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.PaymentRequest.signature)
}
inline void PaymentRequest::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.PaymentRequest.signature)
}
inline void PaymentRequest::set_signature(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.PaymentRequest.signature)
}
inline std::string* PaymentRequest::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000008u;
  return signature_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PaymentRequest::release_signature() {
  // @@protoc_insertion_point(field_release:payments.PaymentRequest.signature)
  if (!has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return signature_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PaymentRequest::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  signature_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentRequest.signature)
}

// -------------------------------------------------------------------

// X509Certificates

// repeated bytes certificate = 1;
inline int X509Certificates::_internal_certificate_size() const {
  return certificate_.size();
}
inline int X509Certificates::certificate_size() const {
  return _internal_certificate_size();
}
inline void X509Certificates::clear_certificate() {
  certificate_.Clear();
}
inline std::string* X509Certificates::add_certificate() {
  // @@protoc_insertion_point(field_add_mutable:payments.X509Certificates.certificate)
  return _internal_add_certificate();
}
inline const std::string& X509Certificates::_internal_certificate(int index) const {
  return certificate_.Get(index);
}
inline const std::string& X509Certificates::certificate(int index) const {
  // @@protoc_insertion_point(field_get:payments.X509Certificates.certificate)
  return _internal_certificate(index);
}
inline std::string* X509Certificates::mutable_certificate(int index) {
  // @@protoc_insertion_point(field_mutable:payments.X509Certificates.certificate)
  return certificate_.Mutable(index);
}
inline void X509Certificates::set_certificate(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:payments.X509Certificates.certificate)
  certificate_.Mutable(index)->assign(value);
}
inline void X509Certificates::set_certificate(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:payments.X509Certificates.certificate)
  certificate_.Mutable(index)->assign(std::move(value));
}
inline void X509Certificates::set_certificate(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  certificate_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:payments.X509Certificates.certificate)
}
inline void X509Certificates::set_certificate(int index, const void* value, size_t size) {
  certificate_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:payments.X509Certificates.certificate)
}
inline std::string* X509Certificates::_internal_add_certificate() {
  return certificate_.Add();
}
inline void X509Certificates::add_certificate(const std::string& value) {
  certificate_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:payments.X509Certificates.certificate)
}
inline void X509Certificates::add_certificate(std::string&& value) {
  certificate_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:payments.X509Certificates.certificate)
}
inline void X509Certificates::add_certificate(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  certificate_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:payments.X509Certificates.certificate)
}
inline void X509Certificates::add_certificate(const void* value, size_t size) {
  certificate_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:payments.X509Certificates.certificate)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
X509Certificates::certificate() const {
  // @@protoc_insertion_point(field_list:payments.X509Certificates.certificate)
  return certificate_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
X509Certificates::mutable_certificate() {
  // @@protoc_insertion_point(field_mutable_list:payments.X509Certificates.certificate)
  return &certificate_;
}

// -------------------------------------------------------------------

// Payment

// optional bytes merchant_data = 1;
inline bool Payment::_internal_has_merchant_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Payment::has_merchant_data() const {
  return _internal_has_merchant_data();
}
inline void Payment::clear_merchant_data() {
  merchant_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Payment::merchant_data() const {
  // @@protoc_insertion_point(field_get:payments.Payment.merchant_data)
  return _internal_merchant_data();
}
inline void Payment::set_merchant_data(const std::string& value) {
  _internal_set_merchant_data(value);
  // @@protoc_insertion_point(field_set:payments.Payment.merchant_data)
}
inline std::string* Payment::mutable_merchant_data() {
  // @@protoc_insertion_point(field_mutable:payments.Payment.merchant_data)
  return _internal_mutable_merchant_data();
}
inline const std::string& Payment::_internal_merchant_data() const {
  return merchant_data_.GetNoArena();
}
inline void Payment::_internal_set_merchant_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  merchant_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Payment::set_merchant_data(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  merchant_data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.Payment.merchant_data)
}
inline void Payment::set_merchant_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  merchant_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.Payment.merchant_data)
}
inline void Payment::set_merchant_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  merchant_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.Payment.merchant_data)
}
inline std::string* Payment::_internal_mutable_merchant_data() {
  _has_bits_[0] |= 0x00000001u;
  return merchant_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Payment::release_merchant_data() {
  // @@protoc_insertion_point(field_release:payments.Payment.merchant_data)
  if (!has_merchant_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return merchant_data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Payment::set_allocated_merchant_data(std::string* merchant_data) {
  if (merchant_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  merchant_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), merchant_data);
  // @@protoc_insertion_point(field_set_allocated:payments.Payment.merchant_data)
}

// repeated bytes transactions = 2;
inline int Payment::_internal_transactions_size() const {
  return transactions_.size();
}
inline int Payment::transactions_size() const {
  return _internal_transactions_size();
}
inline void Payment::clear_transactions() {
  transactions_.Clear();
}
inline std::string* Payment::add_transactions() {
  // @@protoc_insertion_point(field_add_mutable:payments.Payment.transactions)
  return _internal_add_transactions();
}
inline const std::string& Payment::_internal_transactions(int index) const {
  return transactions_.Get(index);
}
inline const std::string& Payment::transactions(int index) const {
  // @@protoc_insertion_point(field_get:payments.Payment.transactions)
  return _internal_transactions(index);
}
inline std::string* Payment::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:payments.Payment.transactions)
  return transactions_.Mutable(index);
}
inline void Payment::set_transactions(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:payments.Payment.transactions)
  transactions_.Mutable(index)->assign(value);
}
inline void Payment::set_transactions(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:payments.Payment.transactions)
  transactions_.Mutable(index)->assign(std::move(value));
}
inline void Payment::set_transactions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  transactions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:payments.Payment.transactions)
}
inline void Payment::set_transactions(int index, const void* value, size_t size) {
  transactions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:payments.Payment.transactions)
}
inline std::string* Payment::_internal_add_transactions() {
  return transactions_.Add();
}
inline void Payment::add_transactions(const std::string& value) {
  transactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:payments.Payment.transactions)
}
inline void Payment::add_transactions(std::string&& value) {
  transactions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:payments.Payment.transactions)
}
inline void Payment::add_transactions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  transactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:payments.Payment.transactions)
}
inline void Payment::add_transactions(const void* value, size_t size) {
  transactions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:payments.Payment.transactions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Payment::transactions() const {
  // @@protoc_insertion_point(field_list:payments.Payment.transactions)
  return transactions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Payment::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:payments.Payment.transactions)
  return &transactions_;
}

// repeated .payments.Output refund_to = 3;
inline int Payment::_internal_refund_to_size() const {
  return refund_to_.size();
}
inline int Payment::refund_to_size() const {
  return _internal_refund_to_size();
}
inline void Payment::clear_refund_to() {
  refund_to_.Clear();
}
inline ::payments::Output* Payment::mutable_refund_to(int index) {
  // @@protoc_insertion_point(field_mutable:payments.Payment.refund_to)
  return refund_to_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payments::Output >*
Payment::mutable_refund_to() {
  // @@protoc_insertion_point(field_mutable_list:payments.Payment.refund_to)
  return &refund_to_;
}
inline const ::payments::Output& Payment::_internal_refund_to(int index) const {
  return refund_to_.Get(index);
}
inline const ::payments::Output& Payment::refund_to(int index) const {
  // @@protoc_insertion_point(field_get:payments.Payment.refund_to)
  return _internal_refund_to(index);
}
inline ::payments::Output* Payment::_internal_add_refund_to() {
  return refund_to_.Add();
}
inline ::payments::Output* Payment::add_refund_to() {
  // @@protoc_insertion_point(field_add:payments.Payment.refund_to)
  return _internal_add_refund_to();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payments::Output >&
Payment::refund_to() const {
  // @@protoc_insertion_point(field_list:payments.Payment.refund_to)
  return refund_to_;
}

// optional string memo = 4;
inline bool Payment::_internal_has_memo() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Payment::has_memo() const {
  return _internal_has_memo();
}
inline void Payment::clear_memo() {
  memo_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Payment::memo() const {
  // @@protoc_insertion_point(field_get:payments.Payment.memo)
  return _internal_memo();
}
inline void Payment::set_memo(const std::string& value) {
  _internal_set_memo(value);
  // @@protoc_insertion_point(field_set:payments.Payment.memo)
}
inline std::string* Payment::mutable_memo() {
  // @@protoc_insertion_point(field_mutable:payments.Payment.memo)
  return _internal_mutable_memo();
}
inline const std::string& Payment::_internal_memo() const {
  return memo_.GetNoArena();
}
inline void Payment::_internal_set_memo(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  memo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Payment::set_memo(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  memo_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.Payment.memo)
}
inline void Payment::set_memo(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  memo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.Payment.memo)
}
inline void Payment::set_memo(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  memo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.Payment.memo)
}
inline std::string* Payment::_internal_mutable_memo() {
  _has_bits_[0] |= 0x00000002u;
  return memo_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Payment::release_memo() {
  // @@protoc_insertion_point(field_release:payments.Payment.memo)
  if (!has_memo()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return memo_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Payment::set_allocated_memo(std::string* memo) {
  if (memo != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  memo_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), memo);
  // @@protoc_insertion_point(field_set_allocated:payments.Payment.memo)
}

// -------------------------------------------------------------------

// PaymentACK

// required .payments.Payment payment = 1;
inline bool PaymentACK::_internal_has_payment() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || payment_ != nullptr);
  return value;
}
inline bool PaymentACK::has_payment() const {
  return _internal_has_payment();
}
inline void PaymentACK::clear_payment() {
  if (payment_ != nullptr) payment_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::payments::Payment& PaymentACK::_internal_payment() const {
  const ::payments::Payment* p = payment_;
  return p != nullptr ? *p : *reinterpret_cast<const ::payments::Payment*>(
      &::payments::_Payment_default_instance_);
}
inline const ::payments::Payment& PaymentACK::payment() const {
  // @@protoc_insertion_point(field_get:payments.PaymentACK.payment)
  return _internal_payment();
}
inline ::payments::Payment* PaymentACK::release_payment() {
  // @@protoc_insertion_point(field_release:payments.PaymentACK.payment)
  _has_bits_[0] &= ~0x00000002u;
  ::payments::Payment* temp = payment_;
  payment_ = nullptr;
  return temp;
}
inline ::payments::Payment* PaymentACK::_internal_mutable_payment() {
  _has_bits_[0] |= 0x00000002u;
  if (payment_ == nullptr) {
    auto* p = CreateMaybeMessage<::payments::Payment>(GetArenaNoVirtual());
    payment_ = p;
  }
  return payment_;
}
inline ::payments::Payment* PaymentACK::mutable_payment() {
  // @@protoc_insertion_point(field_mutable:payments.PaymentACK.payment)
  return _internal_mutable_payment();
}
inline void PaymentACK::set_allocated_payment(::payments::Payment* payment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete payment_;
  }
  if (payment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      payment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payment, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  payment_ = payment;
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentACK.payment)
}

// optional string memo = 2;
inline bool PaymentACK::_internal_has_memo() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PaymentACK::has_memo() const {
  return _internal_has_memo();
}
inline void PaymentACK::clear_memo() {
  memo_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PaymentACK::memo() const {
  // @@protoc_insertion_point(field_get:payments.PaymentACK.memo)
  return _internal_memo();
}
inline void PaymentACK::set_memo(const std::string& value) {
  _internal_set_memo(value);
  // @@protoc_insertion_point(field_set:payments.PaymentACK.memo)
}
inline std::string* PaymentACK::mutable_memo() {
  // @@protoc_insertion_point(field_mutable:payments.PaymentACK.memo)
  return _internal_mutable_memo();
}
inline const std::string& PaymentACK::_internal_memo() const {
  return memo_.GetNoArena();
}
inline void PaymentACK::_internal_set_memo(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  memo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void PaymentACK::set_memo(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  memo_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.PaymentACK.memo)
}
inline void PaymentACK::set_memo(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  memo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.PaymentACK.memo)
}
inline void PaymentACK::set_memo(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  memo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.PaymentACK.memo)
}
inline std::string* PaymentACK::_internal_mutable_memo() {
  _has_bits_[0] |= 0x00000001u;
  return memo_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PaymentACK::release_memo() {
  // @@protoc_insertion_point(field_release:payments.PaymentACK.memo)
  if (!has_memo()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return memo_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PaymentACK::set_allocated_memo(std::string* memo) {
  if (memo != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  memo_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), memo);
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentACK.memo)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace payments

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_paymentrequest_2eproto
